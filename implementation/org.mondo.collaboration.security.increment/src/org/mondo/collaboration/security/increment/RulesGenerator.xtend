/*
 * generated by Xtext 2.10.0
 */
package org.mondo.collaboration.security.increment

import java.util.ArrayList
import java.util.List
import java.util.TreeSet
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.viatra.query.patternlanguage.patternLanguage.PatternModel
import org.eclipse.viatra.query.patternlanguage.patternLanguage.Variable
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.mondo.collaboration.policy.rules.AccessControlModel
import org.mondo.collaboration.policy.rules.AccessibilityLevel
import org.mondo.collaboration.policy.rules.AttributeFact
import org.mondo.collaboration.policy.rules.Binding
import org.mondo.collaboration.policy.rules.Group
import org.mondo.collaboration.policy.rules.ObjectFact
import org.mondo.collaboration.policy.rules.OperationType
import org.mondo.collaboration.policy.rules.Policy
import org.mondo.collaboration.policy.rules.ReferenceFact
import org.mondo.collaboration.policy.rules.ResolutionType
import org.mondo.collaboration.policy.rules.Role
import org.mondo.collaboration.policy.rules.Rule
import org.mondo.collaboration.policy.rules.User

/**
 * Generates code from your AccessControlModel files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class RulesGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		if(resource.contents.head instanceof AccessControlModel) {
			val model = resource.contents.head as AccessControlModel;
		    doGenerate(model, fsa, context);
		} else if(resource.contents.head instanceof EPackage) {
			val metamodel = resource as EPackage
			doGenerate(metamodel, fsa, context);
		} else {
			val root = resource.contents.head as EObject
			val metamodel = root.eClass.EPackage as EPackage
			doGenerate(metamodel, fsa, context);
		}
	}
	
	public def void doGenerate(EPackage metamodel, IFileSystemAccess2 fsa, IGeneratorContext context) {
		fsa.generateFile(metamodel.name+"_gen.vql", generateMetaModelPattern(metamodel))
	}
	
	public def void doGenerateAllInOne(Resource resource, EPackage metamodel, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as AccessControlModel;
		val priorities = model.priorities
	    fsa.generateFile(model.eResource.className+"_all_in_one.vql", generateAllInOne(model, metamodel, priorities));
	}
	
	public def void doGenerate(AccessControlModel model, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val priorities = model.priorities
	    fsa.generateFile(model.eResource.className+"_helper_pattern.vql", generateHelperPattern(model));
	    fsa.generateFile(model.eResource.className+"_explicit_judgement.vql", generateExplicitJudgementPattern(model));
	    fsa.generateFile(model.eResource.className+"_effective_judgement.vql", generateEffectiveJudgementPattern(priorities));
	    fsa.generateFile(model.eResource.className+"_judgement.vql", generateJudgementAtPattern(priorities));
	    fsa.generateFile(model.eResource.className+"_domination_higher_priority.vql", generateDominationHigherPriorityPattern(model, priorities));
	    fsa.generateFile(model.eResource.className+"_domination_same_priority.vql", generateDominationSamePriorityPattern(model, priorities));
	    fsa.generateFile(model.eResource.className+"_consequence.vql", generateConsequencePattern(priorities))
	}
	
	static def mainVQLFile(AccessControlModel model) {
		model.eResource.className+"_all_in_one.vql"	    
	}
	
	static def mainQuerySpecification(PatternModel model, String user) {
		model.patterns.filter[x | x.name.equals("effectiveJudgementOnObjectFor"+user) || x.name.equals("effectiveJudgementOnAttributeFor"+user) || x.name.equals("effectiveJudgementOnReferenceFor"+user)]	    
	}
	
	static def collectVQLFiles(AccessControlModel model, Resource instanceModel) {
		#[ model.eResource.className+"_all_in_one.vql" ]
//		#[  
//			model.eResource.className+"_helper_pattern.vql",
//		    model.eResource.className+"_explicit_judgement.vql",
//		    model.eResource.className+"_effective_judgement.vql",
//		    model.eResource.className+"_judgement.vql", 
//		    model.eResource.className+"_domination_higher_priority.vql", 
//		    model.eResource.className+"_domination_same_priority.vql", 
//		    model.eResource.className+"_consequence.vql",
//		    instanceModel.contents.head.eClass.EPackage.name+"_gen.vql"
//		 ]
	}
	
	static def className(Resource resource) {
		var name = resource.URI.lastSegment
		return name.substring(0, name.indexOf('.'))
	}
	
	def generateAllInOne(AccessControlModel model, EPackage metamodel, TreeSet<Integer> priorities) '''
	«generateImport(metamodel.nsURI)»
	
	«generateUserSpecificPatterns(model, false)»
	«generateHelperPattern(model, false)»
	«generateExplicitJudgementPattern(model, false)»
	«generateEffectiveJudgementPattern(priorities, false)»
	«generateJudgementAtPattern(priorities, false)»
	«generateDominationHigherPriorityPattern(model, priorities, false)»
	«generateDominationSamePriorityPattern(model, priorities, false)»
	«generateConsequencePattern(priorities, false)»
	«generateMetaModelPattern(metamodel, false)»
	'''
	
	def generateImport() {
		generateImport("http://WTSpec4M/5.0M")
	}
    
	def generateImport(String nsUri) '''
    package org.mondo.collaboration.security.query

    import "http://www.eclipse.org/emf/2002/Ecore"
    import "http://www.mondo.org/collaboration/policy/Rules"
    import "«nsUri»"
    '''	

	def generateUserSpecificPatterns(AccessControlModel model) {
		generateUserSpecificPatterns(model, true)
	}
	
	def generateUserSpecificPatterns(AccessControlModel model, boolean requiredImport)'''
	«if(requiredImport) generateImport»
	
	«FOR user: model.roles.usersOfRoleList SEPARATOR "\n"»
	pattern effectiveOJudgementOnObjectForUser«user.name»(object: EObject, operation: OperationType, access: AccessibilityLevel) {
		find effectiveJudgementOnObject(«user.name», object, operation, access)
	}
	
	pattern effectiveOJudgementOnReferenceForUser«user.name»(source: EObject, target: EObject, reference:EReference, operation: OperationType, access: AccessibilityLevel) {
		find effectiveJudgementOnReference(«user.name», source, target, reference, operation, access)
	}	
	
	pattern effectiveOJudgementOnAttributeForUser«user.name»(source: EObject, value: java Object, attribute: EAttribute, operation: OperationType, access: AccessibilityLevel) {
		find effectiveJudgementOnAttribute(«user.name», source, value, attribute, operation, access)
	}
	«ENDFOR»
	'''

	def generateHelperPattern(AccessControlModel model) {
		generateHelperPattern(model, true)
	}
	
    def generateHelperPattern(AccessControlModel model, boolean requiredImport) '''
    «if(requiredImport) generateImport»
    
    pattern readWriteOperation(operation) = {
    	operation == OperationType::READ;
    } or {
    	operation == OperationType::WRITE;
    }
    
    «FOR rule: model.policy.rules SEPARATOR "\n\n" AFTER "\n"»
        «rule.generateAssetHelperPattern»
        «rule.generateUserHelperPattern»
    «ENDFOR»
    
    pattern allUsers(user: java String) {
    	«FOR user: model.roles.usersOfRoleList SEPARATOR "\n} or {"»
    	user == "«user.name»";
    	«ENDFOR»
    }
    '''
    
    def generateExplicitJudgementPattern(AccessControlModel model) {
    	generateExplicitJudgementPattern(model, true)
    }
    
    def generateExplicitJudgementPattern(AccessControlModel model, boolean requiredImport) '''
    «if(requiredImport) generateImport»
    
    pattern explicitJudgementOnObject(user : java String, object : EObject, operation, access, priority : java Integer)
    {
    	
    «FOR rule : model.policy.rules»
        «IF rule.asset instanceof ObjectFact»
            «rule.generateRulePatternOnObject»
            
            } or {
            
        «ENDIF»
    «ENDFOR»
    «model.policy.generateDefaultPatternOnObject»
    }
    
    pattern explicitJudgementOnAttribute(user : java String, source : EObject, value: java Object, attribute : EAttribute, operation, access, priority: java Integer)
    {
    	
    «FOR rule : model.policy.rules»
        «IF rule.asset instanceof AttributeFact»
            «rule.generateRulePatternOnAttribute»
            
            } or {
            
        «ENDIF»
    «ENDFOR»
    «model.policy.generateDefaultPatternOnAttribute»
    }
    
    pattern explicitJudgementOnReference(user : java String, source : EObject, target : EObject, reference : EReference, operation, access, priority: java Integer)
    {
    	
    «FOR rule : model.policy.rules»
        «IF rule.asset instanceof ReferenceFact»
            «rule.generateRulePatternOnReference»
            
            } or {
            
        «ENDIF»
    «ENDFOR»
    «model.policy.generateDefaultPatternOnReference»
    }
    '''

    def generateAssetHelperPattern(Rule rule) '''
    «IF rule.asset instanceof ObjectFact»
        «val object = rule.asset as ObjectFact»
        pattern «rule.name»Asset(«object.variable.name» : EObject) {
    	    find «rule.pattern.name»(«FOR bind: rule.bindList SEPARATOR ", " AFTER ");"»«bind»«ENDFOR»
        }
    «ENDIF»
    «IF rule.asset instanceof AttributeFact»
        «val attribute = rule.asset as AttributeFact»
        pattern «rule.name»Asset(«attribute.variable.name» : EObject, value: java Object, attribute : EAttribute) {
        	find «rule.pattern.name»(«FOR bind: rule.bindList SEPARATOR ", " AFTER ");"»«bind»«ENDFOR»
        	find attributeAsset(«attribute.variable.name», value, attribute);
        	EAttribute.name(attribute, "«attribute.attribute.name»");
        }
    «ENDIF»
    «IF rule.asset instanceof ReferenceFact»
        «val reference = rule.asset as ReferenceFact»
        pattern «rule.name»Asset(«reference.sourceVar» : EObject, «reference.targetVar» : EObject, reference : EReference) {
            find «rule.pattern.name»(«FOR bind: rule.bindList SEPARATOR ", " AFTER ");"»«bind»«ENDFOR»
            find attributeAsset(«reference.sourceVar», «reference.targetVar», reference);
            EReference.name(reference, "«reference.reference.name»");
        }
    «ENDIF»
    '''
    
    def generateUserHelperPattern(Rule rule) '''
    pattern «rule.name»User(user: java String) {
    	«FOR user: rule.roles.usersOfRoleList SEPARATOR "\n} or {" AFTER "}"»
    	user == "«user.name»";
    	«ENDFOR»
    '''
    
    def generateRulePatternOnObject(Rule rule) '''
    //  rule «rule.name»
        find «rule.name»Asset(object);
        find «rule.name»User(user);
        «rule.operation.generateOperationType»
        «rule.access.generateAccessibilityLevel»
        priority == «rule.priority»;
    '''

    def generateDefaultPatternOnObject(Policy policy) '''
    //  rule default
        find objectAsset(object);
        find allUsers(user);
        «policy.operation.generateOperationType»
        «policy.access.generateAccessibilityLevel»
        priority == eval(-1);
    '''
    
    def generateRulePatternOnAttribute(Rule rule) '''
    //  rule «rule.name»
        find «rule.name»Asset(source, value, attribute);
        find «rule.name»User(user);
        «rule.operation.generateOperationType»
        «rule.access.generateAccessibilityLevel»
        priority == «rule.priority»;
    '''

    def generateDefaultPatternOnAttribute(Policy policy) '''
    //  rule default
        find attributeAsset(source, value, attribute);
        find allUsers(user);
        «policy.operation.generateOperationType»
        «policy.access.generateAccessibilityLevel»
        priority == eval(-1);
    '''
    
    def generateRulePatternOnReference(Rule rule) '''
    //  rule «rule.name»
        find «rule.name»Asset(source, target, reference);
        find «rule.name»User(user);
        «rule.operation.generateOperationType»
        «rule.access.generateAccessibilityLevel»
        priority == «rule.priority»;
    '''

    def generateDefaultPatternOnReference(Policy policy) '''
    //  rule default
        find referenceAsset(source, target, reference);
        find allUsers(user);
        «policy.operation.generateOperationType»
        «policy.access.generateAccessibilityLevel»
        priority == eval(-1);
    '''
    
    def generateEffectiveJudgementPattern(TreeSet<Integer> priorities) {
    	generateEffectiveJudgementPattern(priorities, true)
    }
    def generateEffectiveJudgementPattern(TreeSet<Integer> priorities, boolean requiredImport) '''
    «if(requiredImport) generateImport»
    
    pattern effectiveJudgementOnObject(user: java String, object: EObject, operation, access)
    {
    	find effectiveJudgementOnObject_at_default(user, object, operation, access);
    } or {
    	«FOR prio: priorities SEPARATOR "\n} or {"»
    	find effectiveJudgementOnObject_at_«prio»(user, object, operation, access);
    	«ENDFOR»
    }
    
    pattern effectiveJudgementOnObject_at_default(user: java String, object: EObject, operation, access)
    {
    	find judgementOnObject_at_default(user, object, operation, access);
    	neg find dominationOnObject_of_default(user, object, operation);
    }
    
    «FOR prio: priorities SEPARATOR "\n"»
    pattern effectiveJudgementOnObject_at_«prio»(user: java String, object: EObject, operation, access)
    {
        find judgementOnObject_at_«prio»(user, object, operation, access);
        «IF prio != priorities.maxBy[it]»
        	neg find dominationOnObject_of_«prio»(user, object, operation);
        «ENDIF»
    }
    «ENDFOR»
    
    pattern effectiveJudgementOnAttribute(user: java String, source: EObject, value: java Object, attribute: EAttribute, operation, access)
    {
    	find effectiveJudgementOnAttribute_at_default(user, source, value, attribute, operation, access);
    } or {
    	find effectiveJudgementOnAttribute_at_weak(user, source, value, attribute, operation, access);
    } or {
        «FOR prio: priorities SEPARATOR "\n} or {" »
        find effectiveJudgementOnAttribute_at_«prio»(user, source, value, attribute, operation, access);
        «ENDFOR»
    }
    
    pattern effectiveJudgementOnAttribute_at_default(user: java String, source: EObject, value: java Object, attribute: EAttribute, operation, access)
    {
    	find judgementOnAttribute_at_default(user, source, value, attribute, operation, access);
    	neg find dominationOnAttribute_of_default(user, source, value, attribute, operation);
    }
    
    pattern effectiveJudgementOnAttribute_at_weak(user: java String, source: EObject, value: java Object, attribute: EAttribute, operation, access)
    {
        find judgementOnAttribute_at_weak(user, source, value, attribute, operation, access);
        neg find dominationOnAttribute_of_weak(user, source, value, attribute, operation);
    }
    
    «FOR prio: priorities»
    pattern effectiveJudgementOnAttribute_at_«prio»(user: java String, source: EObject, value: java Object, attribute:EAttribute, operation, access)
    {
        find judgementOnAttribute_at_«prio»(user, source, value, attribute, operation, access);
        «IF prio != priorities.maxBy[it]»
        	neg find dominationOnAttribute_of_«prio»(user, source, value, attribute, operation);
        «ENDIF»
    }
    «ENDFOR»
        
    pattern effectiveJudgementOnReference(user: java String, source: EObject, target: EObject, reference:EReference, operation, access) 
    {
    	find effectiveJudgementOnReference_at_default(user, source, target, reference, operation, access);
    } or {
    	find effectiveJudgementOnReference_at_weak(user, source, target, reference, operation, access);
    } or {
        «FOR prio: priorities SEPARATOR "\n} or {" »
        find effectiveJudgementOnReference_at_«prio»(user, source, target, reference, operation, access);
        «ENDFOR»
    }
    
    pattern effectiveJudgementOnReference_at_default(user: java String, source: EObject, target: EObject, reference:EReference, operation, access)
    {
        find judgementOnReference_at_default(user, source, target, reference, operation, access);
        neg find dominationOnReference_of_default(user, source, target, reference, operation);
    }
    
    pattern effectiveJudgementOnReference_at_weak(user: java String, source: EObject, target: EObject, reference:EReference, operation, access)
    {
        find judgementOnReference_at_weak(user, source, target, reference, operation, access);
        neg find dominationOnReference_of_weak(user, source, target, reference, operation);
    }
    
    «FOR prio: priorities»
    pattern effectiveJudgementOnReference_at_«prio»(user: java String, source: EObject, target: EObject, reference:EReference, operation, access)
    {
        find judgementOnReference_at_«prio»(user, source, target, reference, operation, access);
        «IF prio != priorities.maxBy[it]»
        	neg find dominationOnReference_of_«prio»(user, source, target, reference, operation);
        «ENDIF»
    }
    «ENDFOR»
    '''
    
    def generateDominationHigherPriorityPattern(AccessControlModel model, TreeSet<Integer> priorities) {
    	generateDominationHigherPriorityPattern(model, priorities, true)
    }
    
    def generateDominationHigherPriorityPattern(AccessControlModel model, TreeSet<Integer> priorities, boolean requiredImport) '''
    «if(requiredImport) generateImport»
    
    pattern dominationOnObject_of_default(user: java String, object: EObject, operation)
    {
        «FOR prio: priorities SEPARATOR "\n} or {" »
    	find effectiveJudgementOnObject_at_«prio»(user, object, operation, _access);
    	«ENDFOR»
    }
        
    «FOR prio: priorities»«IF prio != priorities.maxBy[it]»
        pattern dominationOnObject_of_«prio»(user: java String, object: EObject, operation) 
        {
        	«FOR prevailingPrio: priorities.filter[it > prio] SEPARATOR "\n} or {" »
        	find effectiveJudgementOnObject_at_«prevailingPrio»(user, object, operation, _access);
        	«ENDFOR»
        } 
        «ENDIF»«ENDFOR»
        
    pattern dominationOnAttribute_of_default(user: java String, source: EObject, value: java Object, attribute: EAttribute, operation)
    {
    	find effectiveJudgementOnAttribute_at_weak(user, source, value, attribute, operation, _access);
    } or {
        «FOR prio: priorities SEPARATOR "\n} or {" »
        find effectiveJudgementOnAttribute_at_«prio»(user, source, value, attribute, operation, _access);
        «ENDFOR»
    }
    
    pattern dominationOnAttribute_of_weak(user: java String, source: EObject, value: java Object, attribute: EAttribute, operation)
    {
        «FOR prio: priorities SEPARATOR "\n} or {" »
            find effectiveJudgementOnAttribute_at_«prio»(user, source, value, attribute, operation, _access);
        «ENDFOR»
    }
        
    «FOR prio: priorities»«IF prio != priorities.maxBy[it]»
        pattern dominationOnAttribute_of_«prio»(user: java String, source: EObject, value: java Object, attribute: EAttribute, operation) 
        {
            «FOR prevailingPrio: priorities.filter[it > prio] SEPARATOR "\n} or {" »
            find effectiveJudgementOnAttribute_at_«prevailingPrio»(user, source, value, attribute, operation, _access);
            «ENDFOR»
        } 
        «ENDIF»«ENDFOR»
          
    pattern dominationOnReference_of_default(user: java String, source: EObject, target: EObject, reference: EReference, operation)
    {
       find effectiveJudgementOnReference_at_weak(user, source, target, reference, operation, _access);
    } or {
        «FOR prio: priorities SEPARATOR "\n} or {" »
        find effectiveJudgementOnReference_at_«prio»(user, source, target, reference, operation, _access);
        «ENDFOR»
    }
         
    pattern dominationOnReference_of_weak(user: java String, source: EObject, target: EObject, reference: EReference, operation)
    {
        «FOR prio: priorities SEPARATOR "\n} or {" »
            find effectiveJudgementOnReference_at_«prio»(user, source, target, reference, operation, _access);
        «ENDFOR»
    }     
       
    «FOR prio: priorities»«IF prio != priorities.maxBy[it]»
        pattern dominationOnReference_of_«prio»(user: java String, source: EObject, target: EObject, reference: EReference, operation) 
        {
            «FOR prevailingPrio: priorities.filter[it > prio] SEPARATOR "\n} or {" »
            find effectiveJudgementOnReference_at_«prevailingPrio»(user, source, target, reference, operation, _access);
            «ENDFOR»
        } 
        «ENDIF»«ENDFOR»
    '''
    
    def generateDominationSamePriorityPattern(AccessControlModel model, TreeSet<Integer> priorities) {
    	generateDominationSamePriorityPattern(model, priorities, true)
    }
    
    def generateDominationSamePriorityPattern(AccessControlModel model, TreeSet<Integer> priorities, boolean requiredImport) '''
    «if(requiredImport) generateImport»
    
    «model.generateResolutionPattern»
    
    «FOR prio: priorities»
    pattern dominatedExplicitJudgementOnObject_at_«prio»(user: java String, object: EObject, operation, dominatedAccess) 
    {
        find explicitJudgementOnObject(user, object, operation, dominatedAccess, «prio»);
        find explicitJudgementOnObject(user, object, operation, prevailingAccess, «prio»);
        find resolution(dominatedAccess, prevailingAccess);
    }
    «ENDFOR»
    
    «FOR prio: priorities»
    pattern dominatedExplicitJudgementOnAttribute_at_«prio»(user: java String, source: EObject, value: java Object, attribute: EAttribute, operation, prevailingAccess) 
    {
        find explicitJudgementOnAttribute(user, source, value, attribute, operation, dominatedAccess, «prio»);
        find explicitJudgementOnAttribute(user, source, value, attribute, operation, prevailingAccess, «prio»);
        find resolution(dominatedAccess, prevailingAccess);
    }
    «ENDFOR»
        
    «FOR prio: priorities»
    pattern dominatedExplicitJudgementOnReference_at_«prio»(user: java String, source: EObject, target: EObject, reference: EReference, operation, prevailingAccess) 
    {
        find explicitJudgementOnReference(user, source, target, reference, operation, dominatedAccess, «prio»);
            find explicitJudgementOnReference(user, source, target, reference, operation, prevailingAccess, «prio»);
        find resolution(dominatedAccess, prevailingAccess);
    }
    «ENDFOR»    
    '''
    
    def generateJudgementAtPattern(TreeSet<Integer> priorities) {
    	generateJudgementAtPattern(priorities, true)
    }    
    
    def generateJudgementAtPattern(TreeSet<Integer> priorities, boolean requiredImport) '''
    «if(requiredImport) generateImport»
    
    «generateJudgementAtDefaultPattern»
    
    «generateJudgementAtWeakPattern»
    
    «FOR prio: priorities SEPARATOR "\n"»
    «prio.generateJudgementAtPrioPattern»
    «ENDFOR»
    '''
    
    def generateJudgementAtDefaultPattern() ''' 
    pattern judgementOnObject_at_default(user: java String, object: EObject, operation, access)
    {
        find explicitJudgementOnObject(user, object, operation, access, eval(-1));
    }
    
    pattern judgementOnAttribute_at_default(user: java String, source: EObject, value: java Object, attribute: EAttribute, operation, access)
    {
        find explicitJudgementOnAttribute(user, source, value, attribute, operation, access, eval(-1));
    }
    
    pattern judgementOnReference_at_default(user: java String, source: EObject, target: EObject, reference: EReference, operation, access)
    {
        find explicitJudgementOnReference(user, source, target, reference, operation, access, eval(-1));
    }
    '''
    
    def generateJudgementAtWeakPattern() '''
    pattern judgementOnAttribute_at_weak(user: java String, source: EObject, value: java Object, attribute: EAttribute, operation, access)
    {
       find weakConsequenceOnAttribute(user, source, value, attribute, operation, access);
    }
        
    pattern judgementOnReference_at_weak(user: java String, source: EObject, target: EObject, reference: EReference, operation, access)
    {
        find weakConsequenceOnReference(user, source, target, reference, operation, access);
    }
    '''
    
    def generateJudgementAtPrioPattern(Integer prio) '''
    pattern judgementOnObject_at_«prio»(user: java String, object: EObject, operation, access)
    {
        find explicitJudgementOnObject(user, object, operation, access, «prio»);
        neg find dominatedExplicitJudgementOnObject_at_«prio»(user, object, operation, access);
    } or {
        find strongConsequenceOnObject_at_«prio»(user, object, operation, access);
«««        «FOR domPrio: priorities»«IF domPrio >= prio»
«««    //} or {
«««    //	find weakConsequence_at_«prio»_of_«domPrio»(user, asset, operation, access, _domAsset, _domOp, _domAccess);
«««         «ENDIF»«ENDFOR»
    }
        
    pattern judgementOnAttribute_at_«prio»(user: java String, source: EObject, value: java Object, attribute: EAttribute, operation, access)
    {
        find explicitJudgementOnAttribute(user, source, value, attribute, operation, access, «prio»);
        neg find dominatedExplicitJudgementOnAttribute_at_«prio»(user, source, value, attribute, operation, access);
    } or {
        find strongConsequenceOnAttribute_at_«prio»(user, source, value, attribute, operation, access);
«««        «FOR domPrio: priorities»«IF domPrio >= prio»
«««    //} or {
«««    //	find weakConsequence_at_«prio»_of_«domPrio»(user, asset, operation, access, _domAsset, _domOp, _domAccess);
«««        «ENDIF»«ENDFOR»
    }
            
    pattern judgementOnReference_at_«prio»(user: java String, source: EObject, target: EObject, reference: EReference, operation, access)
    {
        find explicitJudgementOnReference(user, source, target, reference, operation, access, «prio»);
        neg find dominatedExplicitJudgementOnReference_at_«prio»(user, source, target, reference, operation, access);
    } or {
        find strongConsequenceOnReference_at_«prio»(user, source, target, reference, operation, access);
«««        «FOR domPrio: priorities»«IF domPrio >= prio»
«««    //} or {
«««    //	find weakConsequence_at_«prio»_of_«domPrio»(user, asset, operation, access, _domAsset, _domOp, _domAccess);
«««        «ENDIF»«ENDFOR»
    }
    '''
    
    def generateResolutionPattern(AccessControlModel AccessControlModel) '''
    pattern resolution(dominatedAccess, prevailingAccess)
    {
        «IF AccessControlModel.policy.resolution == ResolutionType.RESTRICTIVE»
        dominatedAccess == AccessibilityLevel::ALLOW;
        prevailingAccess == AccessibilityLevel::DENY;
    } or {
    	dominatedAccess == AccessibilityLevel::ALLOW;
    	prevailingAccess == AccessibilityLevel::OBFUSCATE;
    } or {
    	dominatedAccess == AccessibilityLevel::OBFUSCATE;
    	prevailingAccess == AccessibilityLevel::DENY;
        «ENDIF»
        «IF AccessControlModel.policy.resolution == ResolutionType.PERMISSIVE»
        dominatedAccess == AccessibilityLevel::DENY;
        prevailingAccess == AccessibilityLevel::ALLOW;
    } or {
        dominatedAccess == AccessibilityLevel::DENY;
        prevailingAccess == AccessibilityLevel::OBFUSCATE;
    } or {
        dominatedAccess == AccessibilityLevel::OBFUSCATE;
        prevailingAccess == AccessibilityLevel::ALLOW;
        «ENDIF» 
    }
    '''
    
    def generateConsequencePattern(TreeSet<Integer> priorities) {
    	generateConsequencePattern(priorities, true)
    }
    
    def generateConsequencePattern(TreeSet<Integer> priorities, boolean requiredImport) '''
    «if(requiredImport) generateImport»
    
    «FOR prio: priorities»
    «prio.generateStrongConsequenceOnObject»
    
    «prio.generateStrongConsequenceOnAttribute»
    
    «prio.generateStrongConsequenceOnReference»
    «ENDFOR»
    
    «priorities.generateWeakConsequenceOnAttribute»
            
    «priorities.generateWeakConsequenceOnReference»
    '''
    
    def generateStrongConsequenceOnObject(Integer prio) '''
    pattern strongConsequenceOnObject_at_«prio»(user: java String, object: EObject, operation, access)
    {
    	// allow W -> allow R, object -> object
    	find effectiveJudgementOnObject_at_«prio»(user, object, OperationType::WRITE, AccessibilityLevel::ALLOW);
    	operation == OperationType::READ;
    	access == AccessibilityLevel::ALLOW;
    } or {
    	// deny R -> deny W, object -> object
    	find effectiveJudgementOnObject_at_«prio»(user, object, OperationType::READ, AccessibilityLevel::DENY);
    	operation == OperationType::WRITE;
    	access == AccessibilityLevel::DENY;
    } or {
    	// allow R -> obfuscate R, child -> parent
    	find effectiveJudgementOnObject_at_«prio»(user, child, OperationType::READ, AccessibilityLevel::ALLOW);
    	find contains(object, child);
    	neg find effectiveJudgementOnObject_at_«prio»(user, object, OperationType::READ, AccessibilityLevel::ALLOW);
    	operation == OperationType::READ;
    	access == AccessibilityLevel::OBFUSCATE;
    } or {
    	// allow R -> obfuscate R, attribute -> source
    	find effectiveJudgementOnAttribute_at_«prio»(user, object, _value, _attribute, OperationType::READ, AccessibilityLevel::ALLOW);
    	neg find effectiveJudgementOnObject_at_«prio»(user, object, OperationType::READ, AccessibilityLevel::ALLOW);
    	operation == OperationType::READ;
    	access == AccessibilityLevel::OBFUSCATE;
    } or {
        // deny R, ID attribute -> source
        find effectiveJudgementOnAttribute_at_«prio»(user, object, anyValue, anyAttribute, OperationType::READ, AccessibilityLevel::DENY);
        find idAttribute(object, anyValue, anyAttribute);
        operation == OperationType::READ;
        access == AccessibilityLevel::DENY;
    } or {
        // allow R -> obfuscate R, reference -> source
        find effectiveJudgementOnReference_at_«prio»(user, object, _target, _reference, OperationType::READ, AccessibilityLevel::ALLOW);
        neg find effectiveJudgementOnObject_at_«prio»(user, object, OperationType::READ, AccessibilityLevel::ALLOW);
        operation == OperationType::READ;
        access == AccessibilityLevel::OBFUSCATE;
    } or {
        // allow R -> obfuscate R, reference -> target
        find effectiveJudgementOnReference_at_«prio»(user, _source, object, _reference, OperationType::READ, AccessibilityLevel::ALLOW);
        neg find effectiveJudgementOnObject_at_«prio»(user, object, OperationType::READ, AccessibilityLevel::ALLOW);
        operation == OperationType::READ;
        access == AccessibilityLevel::OBFUSCATE;
    } or {
        // deny R, containment reference -> target
        find effectiveJudgementOnReference_at_«prio»(user, anySource, object, anyReference, OperationType::READ, AccessibilityLevel::DENY);
        find containmentReference(anySource, object, anyReference);
        operation == OperationType::READ;
        access == AccessibilityLevel::DENY;
    } or {
        // allow W, containment reference -> target
        find effectiveJudgementOnReference_at_«prio»(user, anySource, object, anyReference, OperationType::WRITE, AccessibilityLevel::ALLOW);
        find containmentReference(anySource, object, anyReference);
        operation == OperationType::WRITE;
        access == AccessibilityLevel::ALLOW;
    }
    '''
    
    def generateStrongConsequenceOnAttribute(Integer prio) '''
    pattern strongConsequenceOnAttribute_at_«prio»(user: java String, source: EObject, value: java Object, attribute: EAttribute, operation, access)
    {
    	// allow W -> allow R, attribute -> attribute
    	find effectiveJudgementOnAttribute_at_«prio»(user, source, value, attribute, OperationType::WRITE, AccessibilityLevel::ALLOW);
    	operation == OperationType::READ;
    	access == AccessibilityLevel::ALLOW;
    } or {
    	// deny R -> deny W, attribute -> attribute
    	find effectiveJudgementOnAttribute_at_«prio»(user, source, value, attribute, OperationType::READ, AccessibilityLevel::DENY);
    	operation == OperationType::WRITE;
    	access == AccessibilityLevel::DENY;
    } or {
        // allow R, object -> ID attribute
        find effectiveJudgementOnObject_at_«prio»(user, source, OperationType::READ, AccessibilityLevel::ALLOW);
        find idAttribute(source, value, attribute);
        operation == OperationType::READ;
        access == AccessibilityLevel::ALLOW;
    } or {
        // deny W, containment reference -> attribute
        find effectiveJudgementOnReference_at_«prio»(user, anySource, source, anyReference, OperationType::WRITE, AccessibilityLevel::ALLOW);
        find containmentReference(anySource, source, anyReference);
        find attributeAsset(source, value, attribute);
        operation == OperationType::WRITE;
        access == AccessibilityLevel::ALLOW;
    } or {
    	// obfuscate R, object -> ID attribute
    	find effectiveJudgementOnObject_at_«prio»(user, source, OperationType::READ, AccessibilityLevel::OBFUSCATE);
    	find idAttribute(source, value, attribute);
    	operation == OperationType::READ;
    	access == AccessibilityLevel::OBFUSCATE;
    } or {
        // obfuscate R -> deny R, object -> nonID attribute
        find effectiveJudgementOnObject_at_«prio»(user, source, OperationType::READ, AccessibilityLevel::OBFUSCATE);
        find attributeAsset(source, value, attribute);
        neg find idAttribute(source, value, attribute);
        operation == OperationType::READ;
        access == AccessibilityLevel::DENY;
    }
    '''
    
    def generateStrongConsequenceOnReference(Integer prio) '''
    pattern strongConsequenceOnReference_at_«prio»(user: java String, source: EObject, target: EObject, reference: EReference, operation, access)
    {
    	// allow W -> allow R, reference -> reference
    	find effectiveJudgementOnReference_at_«prio»(user, source, target, reference, OperationType::WRITE, AccessibilityLevel::ALLOW);
    	operation == OperationType::READ;
    	access == AccessibilityLevel::ALLOW;
    } or {
    	// deny R -> deny W, reference -> reference
    	find effectiveJudgementOnReference_at_«prio»(user, source, target, reference, OperationType::READ, AccessibilityLevel::DENY);
    	operation == OperationType::WRITE;
    	access == AccessibilityLevel::DENY;
    } or {
        // allow R, object -> container reference
        find effectiveJudgementOnObject_at_«prio»(user, target, OperationType::READ, AccessibilityLevel::ALLOW);
        find containmentReference(source, target, reference);
        operation == OperationType::READ;
        access == AccessibilityLevel::ALLOW;
    } or {
        // deny R, object -> incoming reference
        find effectiveJudgementOnObject_at_«prio»(user, target, OperationType::READ, AccessibilityLevel::DENY);
        find referenceAsset(source, target, reference);
        operation == OperationType::READ;
        access == AccessibilityLevel::DENY;
    } or {
        // deny R, object -> outgoing reference
        find effectiveJudgementOnObject_at_«prio»(user, source, OperationType::READ, AccessibilityLevel::DENY);
        find referenceAsset(source, target, reference);
        operation == OperationType::READ;
        access == AccessibilityLevel::DENY;
    } or {
        // allow W, object -> container reference
        find effectiveJudgementOnObject_at_«prio»(user, target, OperationType::WRITE, AccessibilityLevel::ALLOW);
        find containmentReference(source, target, reference);
        operation == OperationType::WRITE;
        access == AccessibilityLevel::ALLOW;
    } or {
        // deny R, ID attribute -> source
        find effectiveJudgementOnAttribute_at_«prio»(user, target, anyValue, anyAttribute, OperationType::WRITE, AccessibilityLevel::ALLOW);
        find idAttribute(target, anyValue, anyAttribute);
        find referenceAsset(source, target, reference);
        operation == OperationType::WRITE;
        access == AccessibilityLevel::ALLOW;
    }
    '''
    
    def generateWeakConsequenceOnAttribute(TreeSet<Integer> priorities) '''
    pattern weakConsequenceOnAttribute(user: java String, source: EObject, value: java Object, attribute: EAttribute, operation, access)
    {
    	«FOR prio : priorities SEPARATOR "\n} or {"»
    	find effectiveJudgementOnObject_at_«prio»(user, source, operation, access);
    	find attributeAsset(source, value, attribute);
    	«ENDFOR»
    }
    '''
    
    def generateWeakConsequenceOnReference(TreeSet<Integer> priorities) '''
    pattern weakConsequenceOnReference(user: java String, source: EObject, target: EObject, reference: EReference, operation, access)
    {
    	«FOR prio : priorities SEPARATOR "\n} or {"»
    	find effectiveJudgementOnObject_at_«prio»(user, source, operation, access);
    	find referenceAsset(source, target, reference);
    	«ENDFOR»
    }
    '''

    def generateOperationType(OperationType operation) '''
        «IF operation == OperationType.READWRITE»
        find readWriteOperation(operation);
        «ENDIF»
        «IF operation == OperationType.READ»
        operation == OperationType::READ;
        «ENDIF»
        «IF operation == OperationType.WRITE»
        operation == OperationType::WRITE;
        «ENDIF»
    '''

    def generateAccessibilityLevel(AccessibilityLevel access) '''
        «IF access == AccessibilityLevel.ALLOW»
        access == AccessibilityLevel::ALLOW;
        «ENDIF»
        «IF access == AccessibilityLevel.DENY»
        access == AccessibilityLevel::DENY;
        «ENDIF»
    '''

    def getBindList(Rule rule) {
		val bindList = new ArrayList<Object>();
		for (Variable parameter : rule.pattern.parameters) {
			bindList.add(getBindValue(parameter, rule));
		}
		return bindList;
	}
	
	def getBindValue(Variable parameter, Rule rule) {
		for(Binding binding : rule.bindings) {
			if(binding.variable.equals(parameter)){
				if(binding.bind.valueString !== null) {
					return "\"" + binding.bind.valueString + "\"";
				} else {
					return binding.bind.valueInteger;
				}
			}
		}
		if(rule.asset instanceof ObjectFact) {
			val objectAsset = rule.asset as ObjectFact;
			if(objectAsset.variable.equals(parameter)) {
				return objectAsset.variable.name;
			}
		}
		if(rule.asset instanceof AttributeFact) {
			val attributeAsset = rule.asset as AttributeFact;
			if(attributeAsset.variable.equals(parameter)) {
				return attributeAsset.variable.name;
			}
		}
		if(rule.asset instanceof ReferenceFact) {
			val referenceAsset = rule.asset as ReferenceFact;
			if(referenceAsset.sourceVar.equals(parameter)) {
				return referenceAsset.sourceVar.name;
			}
			if(referenceAsset.targetVar.equals(parameter)) {
				return referenceAsset.targetVar.name;
			}
		}
		return "_";
	}
	
	def getUsersOfRoleList(List<Role> roles) {
		val userList = new ArrayList<User>();
		for (Role role : roles) {
			if(role instanceof User) {
				userList.add(role as User);
			} else {
				for (user : getUsersOfGroup(role as Group)) {
					userList.add(user);
				}
			}
		}
		return userList;
	}
	
	def List<User> getUsersOfGroup(Group group){
		val userList = new ArrayList<User>();
		for (role : group.roles) {
			if(role instanceof User){
			    userList.add(role as User);
			} else {
				userList.addAll(getUsersOfGroup(role as Group));
			}
		}
		return userList;
	}
	
	def getPriorities(AccessControlModel AccessControlModel) {
		val priorities = new TreeSet<Integer>();
		for(rule : AccessControlModel.policy.rules) {
			priorities.add(rule.priority);
		}
		return priorities;
	}

	def generateMetaModelPattern(EPackage metamodel) {
		generateMetaModelPattern(metamodel, true)
	}
	
	def generateMetaModelPattern(EPackage metamodel, boolean requiredImport) '''
	«if(requiredImport) generateImport»
	
	«metamodel.generateAttributeAssetPattern»
	
	«metamodel.generateReferenceAssetPattern»
	
	«generateContainmentReferencePattern»
	
	«generateIdAttributePattern»
	
	«metamodel.generateContainsPattern»
	
	«metamodel.generateObjectAssetPattern»
	
	«metamodel.generateRootPattern»
	
	«generateObjectAssetWithoutRootPattern»
	'''

    def generateAttributeAssetPattern(EPackage metamodel)'''
pattern attributeAsset(source : EObject, value: java Object, attribute : EAttribute) {
	«FOR eClass : metamodel.EClassifiers.filter(EClass).filter(x | !x.EAttributes.empty) SEPARATOR "\n} or {"»
		«FOR attribute : eClass.EAttributes SEPARATOR "\n} or {"»
		    find attributeAsset«eClass.name»«attribute.name»(source, value, attribute);
		«ENDFOR»
    «ENDFOR»
}

«FOR eClass : metamodel.EClassifiers.filter(EClass).filter(x | !x.EAttributes.empty) SEPARATOR "\n"»
    «generateAttributeConstraints(eClass)»
«ENDFOR»
	'''
	
	def generateReferenceAssetPattern(EPackage metamodel)'''
pattern referenceAsset(source : EObject, target : EObject, reference : EReference) {
	«FOR eClass : metamodel.EClassifiers.filter(EClass).filter(x | !x.EReferences.empty) SEPARATOR "\n} or {"»
		«FOR reference : eClass.EReferences SEPARATOR "\n} or {"»
		   find referenceAsset«eClass.name»«reference.name»(source, target, reference);     
	    «ENDFOR»
	«ENDFOR»
}

«FOR eClass : metamodel.EClassifiers.filter(EClass).filter(x | !x.EReferences.empty) SEPARATOR "\n"»
    «generateReferenceConstraints(eClass)»
«ENDFOR»
	'''

    def generateContainmentReferencePattern()'''
pattern containmentReference(source : EObject, target : EObject, reference : EReference) {
	find referenceAsset(source, target, reference);
	EReference.containment(reference, true);
}
	'''

    def generateIdAttributePattern()'''
pattern idAttribute(source:EObject, value: java Object, attribute:EAttribute) {
	find attributeAsset(source, value, attribute);
	EAttribute.iD(attribute, true);
}
	'''

    def generateContainsPattern(EPackage metamodel)'''
pattern contains(container: EObject, contained: EObject) {
	«FOR eClass : metamodel.EClassifiers.filter(EClass).filter(x | x.EReferences.exists[y | y.containment]) SEPARATOR "\n} or {"»
		«FOR eReference : eClass.EReferences.filter[x | x.isContainment] SEPARATOR "\n} or {"»
		«eClass.name».«eReference.name»(container, contained);
		«ENDFOR»
    «ENDFOR»
}
	'''
	
	def generateObjectAssetPattern(EPackage metamodel)'''
pattern objectAsset(object: EObject) {
	«FOR eClass : metamodel.EClassifiers.filter(EClass) SEPARATOR "\n} or {"»
		«eClass.name»(object);
    «ENDFOR»
}
	'''
	
	def generateRootPattern(EPackage metamodel)'''
pattern root(object: EObject) {
«««	«FOR eClass : metamodel.EClassifiers.filter(EClass).filter(x | x.eContainer.equals(null)) SEPARATOR "\n} or {"»
    «metamodel.EClassifiers.filter(EClass).head.name»(object);
«««	«ENDFOR»
}
	'''
	
	def generateObjectAssetWithoutRootPattern()'''
	pattern objectAssetWithoutRoot(object: EObject) {
		find objectAsset(object);
		neg find root(object);
	}
	'''

    def generateAttributeConstraints(EClass eClass)'''
        «FOR attribute : eClass.EAttributes SEPARATOR "\n"»
pattern attributeAsset«eClass.name»«attribute.name»(source : EObject, value: java Object, attribute : EAttribute)
{
     «eClass.name».«attribute.name»(source, value);
	 EClass.name(class, "«eClass.name»");
	 EClass.eStructuralFeatures(class, attribute);
	 EAttribute.name(attribute, "«attribute.name»");
}
	    «ENDFOR»
	'''
	
	def generateReferenceConstraints(EClass eClass)'''
        «FOR reference : eClass.EReferences SEPARATOR "\n"»
pattern referenceAsset«eClass.name»«reference.name»(source : EObject, target : EObject, reference : EReference)
{
	«eClass.name».«reference.name»(source, target);
	EClass.name(class, "«eClass.name»");
	EClass.eStructuralFeatures(class, reference);
	EReference.name(reference, "«reference.name»");
}
	    «ENDFOR»
	'''
}
